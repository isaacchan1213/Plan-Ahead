# -*- coding: utf-8 -*-
"""ed-tech-schedule-builder

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zfp1pV0JeaC7XyoJ_LoXecMFyqYXWLIu
"""

import tesseract-ocr
import pytesseract

from google.colab import files

my_image = files.upload()

my_path = list(my_image.keys())[0]

!sudo apt install 
!pip install 
!sudo apt install tesseract-ocr-eng

from datetime import datetime, timedelta

class Schedule:
    def __init__(self):
        # Initialize an empty schedule
        self.schedule = {}

    def add_busy_time(self, start_time, end_time, activity):
        # Convert time strings to datetime objects
        start_datetime = datetime.strptime(start_time, "%I:%M%p")
        end_datetime = datetime.strptime(end_time, "%I:%M%p")

        # Check if the time range overlaps with existing busy times
        for busy_start, busy_end, current_activity in self.schedule.values():
            if (start_datetime < busy_end) and (end_datetime > busy_start):
                print(f"{activity} from {start_time} to {end_time} conflicts with {current_activity} from {busy_start.strftime('%I:%M%p').lower()} to {busy_end.strftime('%I:%M%p').lower()}.")
                return False
        if (end_datetime <= start_datetime):
            print(f"This activity, {activity}, will end at {end_time} the next day.")
            end_datetime = datetime.strptime("12:00am", "%I:%M%p")

        # Add the new busy time to the schedule
        self.schedule[start_time] = (start_datetime, end_datetime, activity)
        return True

    def add_sleep_time(self, start, end):
        self.add_busy_time(start, end, "Sleep")
        return True

    def display_schedule(self):
        print("Busy times:")
        sorted_schedule = sorted(self.schedule.items(), key=lambda x: x[1][0])
        for start_time, (start_datetime, end_datetime, activity) in sorted_schedule:
            print(f"{start_time} - {end_datetime.strftime('%I:%M%p').lower()}: {activity}")
        return

    def __str__(self):
        if self.isEmpty():
          return f"This day has a completely free schedule!\n"
        else:
          s = '\n'
          sorted_schedule = sorted(self.schedule.items(), key=lambda x: x[1][0])
          for start_time, (start_datetime, end_datetime, activity) in sorted_schedule:
            s += f"{start_time} - {end_datetime.strftime('%I:%M%p').lower()}: {activity}\n"
          return s

    def isEmpty(self):
      if self.schedule:
        return False
      else:
        return True

    def get_free_times(self):
        free_times = []
        sorted_schedule = sorted(self.schedule.values(), key=lambda x: x[0])
        prev_end_time = datetime.strptime("12:00am", "%I:%M%p")
        for start_time, end_time, _ in sorted_schedule:
            if start_time > prev_end_time:
                free_times.append((prev_end_time.strftime('%I:%M%p').lower(), start_time.strftime('%I:%M%p').lower()))
            prev_end_time = max(prev_end_time, end_time)
        if prev_end_time < datetime.strptime("12:00am", "%I:%M%p"):
            free_times.append((prev_end_time.strftime('%I:%M%p').lower(), "12:00am"))
        return free_times


    def add_activity_duration(self, activity, total_duration):
        free_times = self.get_free_times()

        # Iterate over free time ranges
        for start_time, end_time in free_times:
            start_datetime = datetime.strptime(start_time, "%I:%M%p")
            end_datetime = datetime.strptime(end_time, "%I:%M%p")

            # Calculate the duration of the current free time slot
            duration = (end_datetime - start_datetime).total_seconds() / 3600  # Convert to hours

            # If there's enough free time to add the entire activity
            if duration >= total_duration:
                self.add_busy_time(start_time, (start_datetime + timedelta(hours=total_duration)).strftime("%I:%M%p"), activity)
                return

            # If there's not enough free time to add the entire activity, add the activity for the available free time
            else:
                self.add_busy_time(start_time, end_time, activity)
                total_duration -= duration

def schedule_activity(activity, duration_per_day, s, days):
  for day in days:
    s[day].add_activity_duration(activity, duration_per_day)

def schedule_sleep(start, end, s, days):
  for day in days:
    s[day].add_sleep_time(start, end)

import pytesseract
from PIL import Image

x = pytesseract.image_to_string(Image.open(my_path))

import re

time_start_stop_pairs = [s.split(' ')for s in re.findall("\d+:\d\d[ap]m \d+:\d\d[ap]m", x)]

for l in time_start_stop_pairs:
  l.append("Class")

pattern = r'(?<=\s)(?!\d{1,2}:\d{2}(?:am|pm))(\S+?)(?=\s\d{1,2}:\d{2}(?:am|pm))'

dates = re.findall(pattern, x)

dates_split = [s.split(',') for s in dates]
dates_split

days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

times_dates = list(zip(dates_split, time_start_stop_pairs))

schedule = {day: Schedule() for day in days}

for l1, l2 in times_dates:
  for day in l1:
    schedule[day].add_busy_time(l2[0], l2[1], l2[2])

# Examples of adding activities
# schedule_activity("Read", 5, schedule, ['Mon', "Thu"])
# schedule_activity("Gym", 2, schedule, days)

for day in days:
  print(f"{day}: {schedule[day]}")